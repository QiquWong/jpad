package standaloneutils.launchers;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Map;

// see: http://www.uavs.us/2011/12/02/matlab-avl-control/

public class AVLExternalJob implements IAVLExternalJob {

	public static void main(String[] args) {
		// Instantiate the job executor object
		AVLExternalJob job = new AVLExternalJob();

		System.out.println("--------------------------------------------- Launch AVL job in a separate process.");

		// Set the AVLROOT environment variable
		String binDirPath = System.getProperty("user.dir") + File.separator  
				+ "src" + File.separator 
				+ "standaloneutils" + File.separator 
				+ "launchers" + File.separator 
				+ "apps" + File.separator 
				+ "AVL" + File.separator 
				+ "bin" 				
				;
		job.setEnvironmentVariable("AVLROOT", binDirPath);

		// Establish the path to dir where the executable file resides 
		job.setBinDirectory(new File(binDirPath));
		System.out.println("Binary directory: " + job.getBinDirectory());

		// Assign the input file
		job.setInputFile(new File(binDirPath + File.separator 
				+ "X-airplane.run"
				));

		//-------------------------------------------------------------------------
		// Generate data
		//
		// NOTE: these data might come from the outside, generated by the 
		//       aircraft design process
		AVLInputData inputData = new AVLInputData
				.Builder()
				/*
				 *    Description
				 */
				.setDescription("(C) Agostino De Marco, agodemar")
				/*
				 *    Mach number
				 */
				.setMain_Mach(0.3) // only one Mach number at time permitted
				/*
				 *   Wing position
				 */
				// ...
				/*
				 *   Build object, finally 
				 *   Validate for all fields to be set, Optional fields are empty	
				 *   
				 */
				.build();

		//-------------------------------------------------------------------------
		// Form the final command to launch the external process
		String commandLine = job.formCommand(binDirPath, inputData);

		// Print out the command line
		System.out.println("Command line: " + commandLine);

		System.out.println("---------------------------------------------");
		System.out.println("EXECUTE JOB:\n");
		int status = job.execute();

		// print the stdout and stderr
		System.out.println("The numeric result of the command was: " + status);
		System.out.println("---------------------------------------------");
		System.out.println("STDOUT:");
		System.out.println(job.getStdOut());
		System.out.println("---------------------------------------------");
		System.out.println("STDERR:");
		System.out.println(job.getStdErr());
		System.out.println("---------------------------------------------");
		System.out.println("Environment variables:");
		Map<String, String> env = job.getEnvironment();
		// env.forEach((k,v)->System.out.println(k + "=" + v));
		System.out.println("AVLROOT=" + env.get("AVLROOT"));
		System.out.println("windir=" + env.get("windir"));
		System.out.println("---------------------------------------------");

/*

		// Parse the AVL output file
		job.parseOutputFile();

		// print the map of variables
		Map<String, List<Number>> variables = job.getAVLOutputReader().getVariables();
		// Print the map of variables
		variables.forEach((key, value) -> {
			System.out.println(key + " = " + value);
		});
		System.out.println("Number of alpha's = " + job.getAVLOutputReader().getNAlphas());

*/

		System.out.println("---------------------------------------------");
		System.out.println("Job terminated.");

	}

	/*
	 *  TODO modify this function as appropriate
	 */
	private String formCommand(String binDirPath, AVLInputData inputData) {

		// build the system command we want to run
		// TODO: handle Win32 and Win64 with separate tags,
		//       handle Linux and Mac iOS as well
		String binShellWin32 = System.getenv("WINDIR") + File.separator
				+ "syswow64"  + File.separator
				+ "cmd.exe"
				;
		System.out.println("Shell Win32 launcher: " + binShellWin32);

		// the Win32 shell cmd.exe
		commandInformation.add(binShellWin32);
		// option /C to cmd.exe
		commandInformation.add("/C");
		// command line to pass to the shell prompt

		//			commandInformation.add("dir"); // must be on Windows
		//			commandInformation.add(
		//					"." + File.separator
		//					+ "src" + File.separator
		//					+ "standaloneutils" + File.separator
		//					+ "launchers"
		//					);

		//			// The following writes a file similar to B-737.dcm
		//			DatcomPlusInputGenerator.writeTemplate(this.getInputFile().getAbsolutePath()); // Ok

		// Write out the input file
		AVLInputGenerator.writeDataToFile(inputData, this.getInputFile().getAbsolutePath());

		System.out.println("Input file full path: " + this.getInputFile());
		System.out.println("Input file name: " + this.getInputFile().getName());

		// Assign the output file
		this.setOutputFile(
				new File(binDirPath + File.separator 
						+ this.getInputFile().getName().replaceFirst(".avl", ".st")
						)
				);

		System.out.println("Output file full path: " + this.getOutputFile());
		System.out.println("Output file name: " + this.getOutputFile().getName());

		commandInformation.add(
				"cd " + binDirPath
				);
		commandInformation.add(
				"& "
						+ "datcom.bat " + this.getInputFile().getName()
				);

		return this.getCommandLine();
	}

	@Override
	public int execute() throws IOException, InterruptedException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public Map<String, String> getEnvironment() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setEnvironmentVariable(String varName, String value) {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean generateInputFile() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean parseOutputFile() {
		// TODO Auto-generated method stub
		return false;
	}

}
